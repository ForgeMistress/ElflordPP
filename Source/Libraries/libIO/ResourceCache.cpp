///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ResourceCache
//
//  Cache that contains handles to all of the resources that are presently loaded.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Copyright (c) Project Firestorm 2018
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ResourceCache.h"

OPEN_NAMESPACE(Firestorm);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*ResourceHandle_::ResourceHandle_(std::nullptr_t)
: _error(nullptr)
, _cache(nullptr)
, _obj(nullptr)
{
}*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandle_::ResourceHandle_(ResourceCache* cache, IResourceObject* obj)
: _error(nullptr)
, _cache(cache)
, _obj(obj)
{
	if(_obj)
		_obj->AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*ResourceHandle_::ResourceHandle_(const ResourceHandle_& other)
: _error(other._error)
, _cache(other._cache)
, _obj(other._obj)
{
	if(_obj)
		_obj->AddRef();
}*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*ResourceHandle_::ResourceHandle_(ResourceHandle_&& other)
: _obj(other._obj)
{
	other._obj = nullptr;
}*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandle_::~ResourceHandle_()
{
	Release();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*ResourceHandle_& ResourceHandle_::operator=(const ResourceHandle_& other)
{
	if(this != &other)
	{
		_obj = other._obj;
		_obj->AddRef();
	}
}*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*ResourceHandle_& ResourceHandle_::operator=(ResourceHandle_&& other)
{
	if(this != &other)
	{
		_obj = other._obj;

		other._obj = nullptr;
	}
}*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*bool ResourceHandle_::operator==(const ResourceHandle_& other)
{
	return _obj == other._obj;
}*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Error ResourceHandle_::GetError() const
{
	return Error(_error);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceHandle_::IsReady() const
{
	return _obj != nullptr && _state == ResourceHandleState::kLoaded;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceHandle_::HasError() const
{
	return _error != nullptr && _state == ResourceHandleState::kLoadError;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleState ResourceHandle_::GetState() const
{
	return _state;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::Release()
{
	DelRef();
	_obj = nullptr;
	_error = nullptr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::SetState(ResourceHandleState state)
{
	_state = state;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::SetResourcePointer(IResourceObject* obj)
{
	DelRef();
	{
		std::scoped_lock lock(_pointerLock);
		_obj = obj;
		_error = nullptr;
	}
	AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::SetError(const ErrorCode* error)
{
	DelRef();

	std::scoped_lock lock(_pointerLock);
	_error = error;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::SetFilename(const String& filename)
{
	_filename = filename;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::AddRef()
{
	std::scoped_lock lock(_pointerLock);
	if(_obj)
		_obj->AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandle_::DelRef()
{
	std::scoped_lock lock(_pointerLock);
	if(_obj)
	{
		if(_obj->DelRef() == 0)
		{
			// TODO: Decide what to do here, otherwise the DelRef should be enough for now.
			_obj = nullptr; // Since the ResourceCache holds ownership, we shouldn't delete. We'll just null it out.
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceCache::ResourceCache()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceCache::~ResourceCache()
{
	std::scoped_lock lock(_lock);
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		auto entry = _cache[i];
		delete entry.object;
	}
	_cache.clear();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceCache::AddResource(const String& name, IResourceObject* resourceObject)
{
	std::scoped_lock lock(_lock);
	FIRE_ASSERT_MSG(resourceObject->GetRefCount() == 0,
					"the resource object was owned by something when it was added to the cache");
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		if(_cache[i].name == name)
			return false;
	}
	_cache.push_back(CacheEntry{
		name,
		resourceObject
	});
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceCache::HasResource(const String& name)
{
	std::scoped_lock lock(_lock);
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		auto& entry = _cache[i];
		if(entry.name == name)
			return true;
	}
	return false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandle ResourceCache::GetResource(const String& resource) const
{
	ResourceHandle_* handle = _handlePool.Get(const_cast<ResourceCache*>(this), FindResource(resource));
	return ResourceHandle(handle, [this](ResourceHandle_* handle){
		_handlePool.Return(handle);
	});
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceCache::ClearOrphanedResources()
{
	std::scoped_lock lock(_lock);
	auto iter = _cache.begin();
	while(iter != _cache.end())
	{
		auto& entry = (*iter);
		// orphaned
		if(entry.object && entry.object->GetRefCount() == 0)
		{
			delete entry.object;
			entry.object = nullptr;
			iter = _cache.erase(iter);
		}
		// otherwise deallocated
		else if(!entry.object)
		{
			iter = _cache.erase(iter);
		}
		else
		{
			++iter;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IResourceObject* ResourceCache::FindResource(const String& name) const
{
	std::scoped_lock lock(_lock);
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		if(_cache[i].name == name)
		{
			return _cache[i].object;
		}
	}
	return nullptr;
}

CLOSE_NAMESPACE(Firestorm);