///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ResourceCache
//
//  Cache that contains handles to all of the resources that are presently loaded.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Copyright (c) Project Firestorm 2018
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ResourceCache.h"

OPEN_NAMESPACE(Firestorm);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ResourceHandleObject::ResourceHandleObject()
: _error(nullptr)
, _cache(nullptr)
, _obj(nullptr)
{
}

ResourceHandleObject::ResourceHandleObject(std::nullptr_t)
: _error(nullptr)
, _cache(nullptr)
, _obj(nullptr)
{

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject::ResourceHandleObject(IResourceObject* obj)
: _error(nullptr)
, _cache(nullptr)
, _obj(nullptr)
{
	if(_obj)
		_obj->AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject::ResourceHandleObject(const ResourceHandleObject& other)
: _obj(other._obj)
{
	if(_obj)
		_obj->AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject::ResourceHandleObject(ResourceHandleObject&& other)
: _obj(other._obj)
{
	other._obj = nullptr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject::~ResourceHandleObject()
{
	if(_obj)
		_obj->DelRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject& ResourceHandleObject::operator=(const ResourceHandleObject& other)
{
	if(this != &other)
	{
		_obj = other._obj;
		_obj->AddRef();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject& ResourceHandleObject::operator=(ResourceHandleObject&& other)
{
	if(this != &other)
	{
		_obj = other._obj;

		other._obj = nullptr;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceHandleObject::operator==(const ResourceHandleObject& other)
{
	return _obj == other._obj;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const IResourceObject* ResourceHandleObject::operator->() const
{
	return _obj;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandleObject::State ResourceHandleObject::GetState() const
{
	return _state;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandleObject::Release()
{
	DelRef();
	_obj = nullptr;
	_error = nullptr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandleObject::SetState(State state)
{
	_state = state;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandleObject::SetResourcePointer(IResourceObject* obj)
{
	DelRef();
	{
		std::scoped_lock lock(_pointerLock);
		_obj = obj;
		_error = nullptr;
	}
	AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandleObject::SetError(const ErrorCode* error)
{
	DelRef();

	std::scoped_lock lock(_pointerLock);
	_error = error;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandleObject::AddRef()
{
	std::scoped_lock lock(_pointerLock);
	if(_obj)
		_obj->AddRef();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceHandleObject::DelRef()
{
	std::scoped_lock lock(_pointerLock);
	if(_obj)
	{
		if(_obj->DelRef() == 0)
		{
			// TODO: Decide what to do here, otherwise the DelRef should be enough for now.
			_obj = nullptr; // Since the ResourceCache holds ownership, we shouldn't delete. We'll just null it out.
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceCache::ResourceCache()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceCache::~ResourceCache()
{
	std::scoped_lock lock(_lock);
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		auto entry = _cache[i];
		delete entry.object;
	}
	_cache.clear();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceCache::AddResource(const String& name, IResourceObject* resourceObject)
{
	std::scoped_lock lock(_lock);
	FIRE_ASSERT_MSG(resourceObject->GetRefCount() == 0,
					"the resource object was owned by something when it was added to the cache");
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		if(_cache[i].name == name)
			return false;
	}
	_cache.push_back(CacheEntry{
		name,
		resourceObject
	});
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ResourceCache::HasResource(const String& name)
{
	std::scoped_lock lock(_lock);
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		auto& entry = _cache[i];
		if(entry.name == name)
			return true;
	}
	return false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ResourceHandle ResourceCache::GetResource(const String& resource) const
{
	return _handlePool.Get(FindResource(resource));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ResourceCache::ClearOrphanedResources()
{
	std::scoped_lock lock(_lock);
	auto iter = _cache.begin();
	while(iter != _cache.end())
	{
		auto& entry = (*iter);
		// orphaned
		if(entry.object && entry.object->GetRefCount() == 0)
		{
			delete entry.object;
			entry.object = nullptr;
			iter = _cache.erase(iter);
		}
		// otherwise deallocated
		else if(!entry.object)
		{
			iter = _cache.erase(iter);
		}
		else
		{
			++iter;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IResourceObject* ResourceCache::FindResource(const String& name) const
{
	std::scoped_lock lock(_lock);
	for(size_t i = 0; i < _cache.size(); ++i)
	{
		if(_cache[i].name == name)
		{
			return _cache[i].object;
		}
	}
	return nullptr;
}

CLOSE_NAMESPACE(Firestorm);