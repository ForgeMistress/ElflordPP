/*
 * BufferFlags.h
 * 
 * This file is part of the "LLGL" project (Copyright (c) 2015-2018 by Lukas Hermanns)
 * See "LICENSE.txt" for license information.
 */

#ifndef LLGL_BUFFER_FLAG_H
#define LLGL_BUFFER_FLAG_H


#include "Export.h"
#include "VertexFormat.h"
#include "IndexFormat.h"
#include "RenderSystemFlags.h"
#include <string>
#include <cstdint>


namespace LLGL
{


/* ----- Enumerations ----- */

/**
\brief Hardware buffer type enumeration.
\see ResourceType
\todo Maybe replace this enum by "ResourceType".
*/
enum class BufferType
{
    //! Vertex buffer type.
    Vertex,

    //! Index buffer type.
    Index,

    //! Constant buffer type (also called "Uniform Buffer Object").
    Constant,

    //! Storage buffer type (also called "Shader Storage Buffer Object" or "Read/Write Buffer").
    Storage,

    /**
    \brief Stream output buffer type (also called "Transform Feedback Buffer").
    \note Only supported with: OpenGL, Direct3D 11, Direct3D 12.
    */
    StreamOutput,

    #if 0//TODO: planned for v0.03
    /**
    \brief Result buffer type for query heaps.
    \see CommandBuffer::ResolveQuery
    */
    QueryResult,
    #endif
};

/**
\brief Storage buffer type enumeration.
\note Only supported with: Direct3D 11, Direct3D 12.
*/
enum class StorageBufferType
{
    Undefined,                  //!< Undefined storage buffer type.
    Buffer,                     //!< Typed buffer.
    StructuredBuffer,           //!< Structured buffer.
    ByteAddressBuffer,          //!< Byte-address buffer.
    RWBuffer,                   //!< Typed read/write buffer.
    RWStructuredBuffer,         //!< Structured read/write buffer.
    RWByteAddressBuffer,        //!< Byte-address read/write buffer.
    AppendStructuredBuffer,     //!< Append structured buffer.
    ConsumeStructuredBuffer,    //!< Consume structured buffer.
};

/**
\brief Buffer creation flags enumeration.
\see BufferDescriptor::flags
*/
struct BufferFlags
{
    enum
    {
        /**
        \brief Buffer mapping with CPU read access is required.
        \see RenderSystem::MapBuffer
        */
        MapReadAccess       = (1 << 0),

        /**
        \brief Buffer mapping with CPU write access is required.
        \see RenderSystem::MapBuffer
        */
        MapWriteAccess      = (1 << 1),

        /*
        \brief Buffer mapping with CPU read and write access is required.
        \see BufferFlags::MapReadAccess
        \see BufferFlags::MapWriteAccess
        */
        MapReadWriteAccess  = (MapReadAccess | MapWriteAccess),

        /**
        \brief Hint to the renderer that the buffer will be frequently updated from the CPU.
        \remarks This is useful for a constant buffer for instance, that is updated by the host program every frame.
        \see RenderSystem::WriteBuffer
        */
        DynamicUsage        = (1 << 2),
    };
};


/* ----- Structures ----- */

//! Hardware buffer descriptor structure.
struct BufferDescriptor
{
    //! Vertex buffer specific descriptor structure.
    struct VertexBuffer
    {
        /**
        \brief Specifies the vertex format layout.
        \remarks This is required to tell the renderer how the vertex attributes are stored inside the vertex buffer and
        it must be the same vertex format which is used for the respective graphics pipeline shader program.
        */
        VertexFormat format;
    };

    //! Index buffer specific descriptor structure.
    struct IndexBuffer
    {
        /**
        \brief Specifies the index format layout, which is basically only the data type of each index.
        \remarks The only valid format types for an index buffer are: DataType::UByte, DataType::UShort, and DataType::UInt.
        \see DataType
        */
        IndexFormat format;
    };

    //! Storage buffer specific descriptor structure.
    struct StorageBuffer
    {
        /**
        \brief Specifies the storage buffer type. By defalut StorageBufferType::Undefined.
        \remarks In OpenGL there are only generic storage buffers (or rather "Shader Storage Buffer Objects").
        However, a valid type should always be specified when a storage buffer is created.
        */
        StorageBufferType   storageType = StorageBufferType::Undefined;

        /**
        \brief Specifies the vector format of a typed buffer. By default Format::Undefined.
        \remarks This is only used if the storage type is either StorageBufferType::Buffer or StorageBufferType::RWBuffer.
        \see IsStorageBufferTyped
        */
        Format              format      = Format::Undefined;

        /**
        \brief Specifies the stride (in bytes) of each element in a storage buffer.
        \remarks If this value is zero, the behavior of the buffer creation is undefined.
        */
        std::uint32_t       stride      = 0;
    };

    //! Hardware buffer type. By default BufferType::Vertex.
    BufferType      type            = BufferType::Vertex;

    /**
    \brief Specifies the buffer creation flags. By default 0.
    \remarks This can be bitwise OR combination of the entries of the BufferFlags enumeration.
    \see BufferFlags
    */
    long            flags           = 0;

    /**
    \brief Buffer size (in bytes). This must not be larger than 'RenderingLimits::maxBufferSize'. By default 0.
    \remarks If the buffer type is a storage buffer (i.e. from the type BufferType::Storage), 'size' must be a multiple of 'storageBuffer.stride'.
    \see RenderingLimits::maxBufferSize
    */
    std::uint64_t   size            = 0;

    //! Vertex buffer type descriptor appendix.
    VertexBuffer    vertexBuffer;

    //! Index buffer type descriptor appendix.
    IndexBuffer     indexBuffer;

    //! Storage buffer type descriptor appendix.
    StorageBuffer   storageBuffer;
};


/* ----- Functions ----- */

/**
\defgroup group_buffer_util Buffer utility functions to determine buffer types.
\addtogroup group_buffer_util
@{
*/

/**
\brief Returns true if the storage buffer type denotes a read/write (RW) buffer.
\return True if \c type either StorageBufferType::RWBuffer, StorageBufferType::RWStructuredBuffer,
StorageBufferType::RWByteAddressBuffer, StorageBufferType::AppendStructuredBuffer, or StorageBufferType::ConsumeStructuredBuffer.
*/
LLGL_EXPORT bool IsRWBuffer(const StorageBufferType type);

/**
\brief Returns true if the storage buffer type denotes a simply typed buffer.
\return True if \c type either StorageBufferType::Buffer or StorageBufferType::RWBuffer.
*/
LLGL_EXPORT bool IsTypedBuffer(const StorageBufferType type);

/**
\brief Returns true if the storage buffer type denotes a structured buffer.
\return True if \c type either StorageBufferType::StructuredBuffer, StorageBufferType::RWStructuredBuffer,
StorageBufferType::AppendStructuredBuffer, or StorageBufferType::ConsumeStructuredBuffer.
*/
LLGL_EXPORT bool IsStructuredBuffer(const StorageBufferType type);

/**
\brief Returns true if the storage buffer type denotes a byte addresse buffer.
\return True if \c type either StorageBufferType::ByteAddressBuffer or StorageBufferType::RWByteAddressBuffer.
*/
LLGL_EXPORT bool IsByteAddressBuffer(const StorageBufferType type);

/** @} */


} // /namespace LLGL


#endif



// ================================================================================
